const std = @import("std");

pub const Definitions = struct {
    build: *std.Build,
    database: std.StringHashMap(void),
    text: std.ArrayList(u8),
    step: std.Build.Step,
    output_path: [128]u8 = .{0} ** 128,

    /// for the custom build step
    fn makeFn(step: *std.Build.Step, prog_node: std.Progress.Node) anyerror!void {
        //_ = prog_node; // autofix

        const node = prog_node.start("Writing lua definitions file", 1);
        defer node.end();
        const self: *Definitions = @fieldParentPtr("step", step);

        const path = self.build.path(std.mem.sliceTo(&self.output_path, 0)).getPath(self.build);
        var file = try std.fs.createFileAbsolute(path, .{});
        defer file.close();

        try file.seekTo(0);
        try file.writeAll(self.text.items);
        try file.setEndPos(try file.getPos());
    }

    pub fn init(b: *std.Build, output_path: []const u8) @This() {
        var result = Definitions{
            .step = std.Build.Step.init(.{
                .id = .custom,
                .name = "generate definitions.lua",
                .owner = b,
                .makeFn = &makeFn,
            }),
            .build = b,
            .database = std.StringHashMap(void).init(b.allocator),
            .text = std.ArrayList(u8).init(b.allocator),
        };
        std.mem.copyForwards(u8, &result.output_path, output_path);
        return result;
    }

    pub fn deinit(self: *@This()) void {
        _ = self; // autofix
        //_ = self;
        //std.debug.print("deinit called\n", .{});
        //self.text.deinit();
        //self.database.deinit();
    }

    fn getFileHeader(_: *@This()) []const u8 {
        return 
        \\---@meta
        \\
        \\--- This is an autogenerated file,
        \\--- Do not modify
        \\
        \\
        ;
    }

    pub fn addEnum(self: *@This(), name: []const u8, comptime T: type) !void {
        if (self.database.contains(name) == false) {
            try self.database.put(name, {});

            //name
            try self.text.appendSlice("---@alias ");
            try self.text.appendSlice(name);
            try self.text.appendSlice("\n");

            inline for (@typeInfo(T).Enum.fields) |field| {
                try self.text.appendSlice("---|\' \"");
                try self.text.appendSlice(field.name);
                try self.text.appendSlice("\" \'\n");
            }
        }
    }

    pub fn addClass(self: *@This(), name: []const u8, comptime T: type) !void {
        if (self.database.contains(name) == false) {
            try self.database.put(name, {});
            try self.addClassName(name);
            try self.addClassFields(@typeInfo(T).Struct.fields);
        }
    }

    fn addClassName(self: *@This(), name: []const u8) !void {
        try self.text.appendSlice("---@class ");
        try self.text.appendSlice(name);
        try self.text.appendSlice("\n");
    }

    fn addClassField(self: *@This(), comptime field: std.builtin.Type.StructField) !void {
        try self.text.appendSlice("---@field ");
        try self.text.appendSlice(field.name);
        try self.text.appendSlice(" ");
        try self.addType(field.type);
        try self.text.appendSlice("\n");
    }

    fn addClassFields(
        self: *@This(),
        comptime fields: []const std.builtin.Type.StructField,
    ) !void {
        if (fields.len > 0) {
            try self.addClassField(fields[0]);
            try self.addClassFields(fields[1..fields.len]);
        } else {
            return;
        }
    }

    fn addType(self: *@This(), comptime T: type) !void {
        switch (@typeInfo(T)) {
            .Struct => {
                const name = (comptime std.fs.path.extension(@typeName(T)))[1..];
                try self.addClass(name, T);
                try self.text.appendSlice(name);
            },
            .Pointer => |info| {
                if (info.child == u8 and info.size == .Slice) {
                    try self.text.appendSlice("string");
                } else switch (info.size) {
                    .One => {
                        try self.text.appendSlice("lightuserdata");
                    },
                    .C, .Many, .Slice => {
                        try self.addType(info.child);
                        try self.text.appendSlice("[]");
                    },
                }
            },
            .Array => |info| {
                try self.addType(info.child);
                try self.text.appendSlice("[]");
            },

            .Vector => |info| {
                try self.addType(info.child);
                try self.text.appendSlice("[]");
            },
            .Optional => |info| {
                try self.addType(info.child);
                try self.text.appendSlice("|nil");
            },
            .Enum => {
                //const name = @typeName(T);
                const name = (comptime std.fs.path.extension(@typeName(T)))[1..];
                try self.addEnum(name, T);
                try self.text.appendSlice(name);
            },
            .Int => {
                try self.text.appendSlice("integer");
            },
            .Float => {
                try self.text.appendSlice("number");
            },
            .Bool => {
                try self.text.appendSlice("boolean");
            },
            else => @compileError("Type not supported"),
        }
    }

    /// Warning: file contents will be lost
    fn overwriteFile(self: *@This(), abs_path: []const u8) !void {
        var file = try std.fs.openFileAbsolute(abs_path, .{ .mode = .write_only });
        try file.seekTo(0);
        try file.writeAll(self.getFileHeader());

        var iter = self.database.valueIterator();
        while (iter.next()) |val| {
            try file.writeAll(val.items);
            try file.writeAll("\n");
        }
        try file.setEndPos(try file.getPos());
    }

    pub fn printdatabase(self: *@This()) !void {
        var iter = self.database.valueIterator();
        while (iter.next()) |val| {
            std.debug.print("{s}\n", .{val.items});
        }
    }

    //fn toString(self: *@This()) ![]const u8 {
    //    var self.text = std.ArrayList(u8).init(self.build.allocator);

    //    try self.text.appendSlice(self.getFileHeader());
    //    var iter = self.database.valueIterator();
    //    while (iter.next()) |val| {
    //        try self.text.appendSlice(val.items);
    //        try self.text.appendSlice("\n");
    //    }
    //    return self.text.items;
    //}
};

//,test "docgen" {
//,    var docs = Definitions.init(std.testing.allocator);
//,    defer docs.deinit();
//,
//,    const MyEnum = enum { asdf, fdsa, qwer, rewq };
//,    const SubType = struct { foo: i32, bar: bool, bip: MyEnum, bap: ?[]MyEnum };
//,    const Bippity = struct { A: ?i32, B: *bool, C: []const u8, D: ?*SubType };
//,    const TestType = struct { a: i32, b: f32, c: bool, d: SubType, e: [10]Bippity };
//,    try docs.addClass("TestType", TestType);
//,    //try docs.printdatabase();
//,}
