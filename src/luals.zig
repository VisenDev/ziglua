const std = @import("std");

pub const Definitions = struct {
    build: *std.Build,
    database: std.StringHashMap(std.ArrayList(u8)),
    step: std.Build.Step,
    output_path: std.Build.LazyPath,

    /// for the custom build step
    fn makeFn(step: *std.Build.Step, prog_node: std.Progress.Node) anyerror!void {
        _ = prog_node; // autofix
        const self: *Definitions = @fieldParentPtr("step", step);

        //const text = try self.toString();

        var text = std.ArrayList(u8).init(self.build.allocator);
        defer text.deinit();

        try text.appendSlice(self.getFileHeader());
        var iter = self.database.valueIterator();
        while (iter.next()) |val| {
            try text.appendSlice(val.items);
            try text.appendSlice("\n");
        }

        var file = try std.fs.createFileAbsolute(self.output_path.getPath(self.build), .{});
        defer file.close();

        try file.seekTo(0);
        try file.writeAll(text.items);
        try file.setEndPos(try file.getPos());
    }

    pub fn init(b: *std.Build, output_path: std.Build.LazyPath) @This() {
        return Definitions{
            .step = std.Build.Step.init(.{
                .id = .custom,
                .name = "generate definitions.lua",
                .owner = b,
                .makeFn = &makeFn,
            }),
            .build = b,
            .database = std.StringHashMap(std.ArrayList(u8)).init(b.allocator),
            .output_path = output_path,
        };
    }

    pub fn deinit(self: *@This()) void {
        std.debug.print("deinit called\n", .{});
        var iter = self.database.valueIterator();
        while (iter.next()) |val| {
            val.deinit();
        }
        self.database.deinit();
    }

    pub fn getFileHeader(_: *@This()) []const u8 {
        return 
        \\---@meta
        \\
        \\--- This is an autogenerated file,
        \\--- Do not modify
        \\
        \\
        ;
    }

    pub fn addEnum(self: *@This(), name: []const u8, comptime T: type) !void {
        const is_undatabase = self.database.get(name) == null;
        if (is_undatabase) {
            try self.database.put(name, std.ArrayList(u8).init(self.build.allocator));
            const result = self.database.getPtr(name).?;

            //name
            try result.appendSlice("---@alias ");
            try result.appendSlice(name);
            try result.appendSlice("\n");

            inline for (@typeInfo(T).Enum.fields) |field| {
                try result.appendSlice("---|\' \"");
                try result.appendSlice(field.name);
                try result.appendSlice("\" \'\n");
            }
        }
    }

    pub fn addClass(self: *@This(), name: []const u8, comptime T: type) !void {
        const is_undatabase = self.database.get(name) == null;
        if (is_undatabase) {
            try self.database.put(name, std.ArrayList(u8).init(self.build.allocator));
            const result = self.database.getPtr(name).?;
            try self.addClassName(result, name);
            try self.addClassFields(result, @typeInfo(T).Struct.fields);
        }
    }

    pub fn addClassName(_: *@This(), result: *std.ArrayList(u8), name: []const u8) !void {
        try result.appendSlice("---@class ");
        try result.appendSlice(name);
        try result.appendSlice("\n");
    }

    pub fn addClassField(self: *@This(), result: *std.ArrayList(u8), comptime field: std.builtin.Type.StructField) !void {
        try result.appendSlice("---@field ");
        try result.appendSlice(field.name);
        try result.appendSlice(" ");
        try self.addType(result, field.type);
        try result.appendSlice("\n");
    }

    pub fn addClassFields(
        self: *@This(),
        result: *std.ArrayList(u8),
        comptime fields: []const std.builtin.Type.StructField,
    ) !void {
        if (fields.len > 0) {
            try self.addClassField(result, fields[0]);
            try self.addClassFields(result, fields[1..fields.len]);
        } else {
            return;
        }
    }

    pub fn addType(self: *@This(), result: *std.ArrayList(u8), comptime T: type) !void {
        switch (@typeInfo(T)) {
            .Struct => {
                const name = (comptime std.fs.path.extension(@typeName(T)))[1..];
                try self.addClass(name, T);
                try result.appendSlice(name);
            },
            .Pointer => |info| {
                if (info.child == u8 and info.size == .Slice) {
                    try result.appendSlice("string");
                } else switch (info.size) {
                    .One => {
                        try result.appendSlice("lightuserdata");
                    },
                    .C, .Many, .Slice => {
                        try self.addType(result, info.child);
                        try result.appendSlice("[]");
                    },
                }
            },
            .Array => |info| {
                try self.addType(result, info.child);
                try result.appendSlice("[]");
            },

            .Vector => |info| {
                try self.addType(result, info.child);
                try result.appendSlice("[]");
            },
            .Optional => |info| {
                try self.addType(result, info.child);
                try result.appendSlice("|nil");
            },
            .Enum => {
                //const name = @typeName(T);
                const name = (comptime std.fs.path.extension(@typeName(T)))[1..];
                try self.addEnum(name, T);
                try result.appendSlice(name);
            },
            .Int => {
                try result.appendSlice("integer");
            },
            .Float => {
                try result.appendSlice("number");
            },
            .Bool => {
                try result.appendSlice("boolean");
            },
            else => @compileError("Type not supported"),
        }
    }

    /// Warning: file contents will be lost
    pub fn overwriteFile(self: *@This(), abs_path: []const u8) !void {
        var file = try std.fs.openFileAbsolute(abs_path, .{ .mode = .write_only });
        try file.seekTo(0);
        try file.writeAll(self.getFileHeader());

        var iter = self.database.valueIterator();
        while (iter.next()) |val| {
            try file.writeAll(val.items);
            try file.writeAll("\n");
        }
        try file.setEndPos(try file.getPos());
    }

    pub fn printdatabase(self: *@This()) !void {
        var iter = self.database.valueIterator();
        while (iter.next()) |val| {
            std.debug.print("{s}\n", .{val.items});
        }
    }

    pub fn toString(self: *@This()) ![]const u8 {
        var result = std.ArrayList(u8).init(self.build.allocator);

        try result.appendSlice(self.getFileHeader());
        var iter = self.database.valueIterator();
        while (iter.next()) |val| {
            try result.appendSlice(val.items);
            try result.appendSlice("\n");
        }
        return result.items;
    }
};

//,test "docgen" {
//,    var docs = Definitions.init(std.testing.allocator);
//,    defer docs.deinit();
//,
//,    const MyEnum = enum { asdf, fdsa, qwer, rewq };
//,    const SubType = struct { foo: i32, bar: bool, bip: MyEnum, bap: ?[]MyEnum };
//,    const Bippity = struct { A: ?i32, B: *bool, C: []const u8, D: ?*SubType };
//,    const TestType = struct { a: i32, b: f32, c: bool, d: SubType, e: [10]Bippity };
//,    try docs.addClass("TestType", TestType);
//,    //try docs.printdatabase();
//,}
