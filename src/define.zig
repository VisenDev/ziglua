const std = @import("std");

const String = std.ArrayListUnmanaged(u8);
const Database = std.StringHashMap(String);

pub const DefineEntry = struct {
    type: type,
    name: []const u8,
};

pub fn define(
    alloc: std.mem.Allocator,
    absolute_output_path: []const u8,
    comptime to_define: []const DefineEntry,
) !void {
    var database = Database.init(alloc);
    defer database.deinit();

    inline for (to_define) |def| {
        std.debug.print("defining: {any}\n", .{def.type});
        _ = try addClass(alloc, &database, def.type);
        std.debug.print("finished defining: {any}\n", .{def.type});
        std.debug.print("actual stored value: \n\n{s}\n\n", .{database.get(@typeName(def.type)).?.items});
    }

    std.debug.print("opening output file: {s}\n", .{absolute_output_path});
    var file = try std.fs.createFileAbsolute(absolute_output_path, .{});
    defer file.close();

    try file.seekTo(0);
    try file.writeAll(file_header);

    std.debug.print("writing to file\n", .{});
    var iter = database.iterator();
    while (iter.next()) |val| {
        std.debug.print(" - writing item: {s}\n", .{val.key_ptr.*});
        try file.writeAll(val.value_ptr.items);
        try file.writeAll("\n");
    }
    std.debug.print("finished writing to file\n", .{});

    try file.setEndPos(try file.getPos());

    std.debug.print("Freeing memory\n", .{});
    iter = database.iterator();
    while (iter.next()) |val| {
        val.value_ptr.deinit(alloc);
    }
}

const file_header: []const u8 =
    \\---@meta
    \\
    \\--- This is an autogenerated file,
    \\--- Do not modify
    \\
    \\
;

fn addEnum(
    alloc: std.mem.Allocator,
    database: *Database,
    comptime T: type,
) ![]const u8 {
    const name = (comptime std.fs.path.extension(@typeName(T)))[1..];
    if (database.contains(@typeName(T)) == false) {
        const text_basis = try String.initCapacity(alloc, 16);
        try database.putNoClobber(@typeName(T), text_basis);
        const text = database.getPtr(@typeName(T)).?;

        try text.appendSlice(alloc, "---@alias ");
        try text.appendSlice(alloc, name);
        try text.appendSlice(alloc, "\n");

        inline for (@typeInfo(T).Enum.fields) |field| {
            try text.appendSlice(alloc, "---|\' \"");
            try text.appendSlice(alloc, field.name);
            try text.appendSlice(alloc, "\" \'\n");
        }
    }
    return name;
}

fn addClass(alloc: std.mem.Allocator, database: *Database, comptime T: type) ![]const u8 {
    const name = (comptime std.fs.path.extension(@typeName(T)))[1..];
    if (database.contains(@typeName(T)) == false) {
        const text_basis = try String.initCapacity(alloc, 16);
        try database.putNoClobber(@typeName(T), text_basis);
        const text = database.getPtr(@typeName(T)).?;

        std.debug.print("defining: {s}\n", .{name});
        try addClassName(alloc, text, name);
        try addClassFields(alloc, database, text, @typeInfo(T).Struct.fields);
        std.debug.print("finished defining: {s}\n", .{name});
        std.debug.print("final value: \n{s}\n", .{text.items});
    }
    return name;
}

fn addClassName(alloc: std.mem.Allocator, text: *String, name: []const u8) !void {
    try text.appendSlice(alloc, "---@class ");
    try text.appendSlice(alloc, name);
    try text.appendSlice(alloc, "\n");
}

fn addClassField(alloc: std.mem.Allocator, database: *Database, text: *String, comptime field: std.builtin.Type.StructField) !void {
    std.debug.print(" - adding field: {s}\n", .{field.name});
    try text.appendSlice(alloc, "---@field ");
    try text.appendSlice(alloc, field.name);
    try text.appendSlice(alloc, " ");
    try addType(alloc, database, text, field.type);
    try text.appendSlice(alloc, "\n");
}

fn addClassFields(
    alloc: std.mem.Allocator,
    database: *Database,
    text: *String,
    comptime fields: []const std.builtin.Type.StructField,
) !void {
    if (fields.len > 0) {
        try addClassField(alloc, database, text, fields[0]);
        try addClassFields(alloc, database, text, fields[1..fields.len]);
    } else {
        return;
    }
}

fn addType(alloc: std.mem.Allocator, database: *Database, text: *String, comptime T: type) !void {
    switch (@typeInfo(T)) {
        .Struct => {
            const name = try addClass(alloc, database, T);
            try text.appendSlice(alloc, name);
        },
        .Pointer => |info| {
            if (info.child == u8 and info.size == .Slice) {
                try text.appendSlice(alloc, "string");
            } else switch (info.size) {
                .One => {
                    try text.appendSlice(alloc, "lightuserdata");
                },
                .C, .Many, .Slice => {
                    try addType(alloc, database, text, info.child);
                    try text.appendSlice(alloc, "[]");
                },
            }
        },
        .Array => |info| {
            try addType(alloc, database, text, info.child);
            try text.appendSlice(alloc, "[]");
        },

        .Vector => |info| {
            try addType(alloc, database, text, info.child);
            try text.appendSlice(alloc, "[]");
        },
        .Optional => |info| {
            try addType(alloc, database, text, info.child);
            try text.appendSlice(alloc, "?");
        },
        .Enum => {
            const name = try addEnum(alloc, database, T);
            try text.appendSlice(alloc, name);
        },
        .Int => {
            try text.appendSlice(alloc, "integer");
        },
        .Float => {
            try text.appendSlice(alloc, "number");
        },
        .Bool => {
            try text.appendSlice(alloc, "boolean");
        },
        else => {
            @compileLog(T);
            @compileError("Type not supported");
        },
    }
}
