const std = @import("std");

const String = std.ArrayList(u8);
const Database = std.StringHashMap(String);

pub const DefineEntry = struct {
    type: type,
    name: []const u8,
};

pub fn Define(comptime to_define: []const DefineEntry) type {
    return struct {
        path: std.Build.LazyPath,
        step: *std.Build.Step,

        pub fn makeFn(step: *std.Build.Step, prog_node: std.Progress.Node) anyerror!void {
            _ = prog_node; // autofix

            std.debug.print("makeFn called\n", .{});
            //pro

            var database = Database.init(step.owner.allocator);
            defer database.deinit();

            inline for (to_define) |define| {
                try addClass(step.owner, &database, define.name, define.type);
            }

            var iter = database.valueIterator();
            while (iter.next()) |val| {
                std.debug.print("{s}\n", .{val.items});
                val.deinit();
            }
        }

        pub fn init(b: *std.Build, output_path: std.Build.LazyPath) !@This() {
            const result: @This() = .{
                .step = try b.allocator.create(std.Build.Step),
                .path = output_path,
            };

            result.step.* = std.Build.Step.init(.{
                .id = .custom,
                .name = "Generate definitions.lua",
                .owner = b,
                .makeFn = &makeFn,
            });
            return result;
        }
    };
}

fn getFileHeader() []const u8 {
    return 
    \\---@meta
    \\
    \\--- This is an autogenerated file,
    \\--- Do not modify
    \\
    \\
    ;
}

fn addEnum(b: *std.Build, database: *Database, name: []const u8, comptime T: type) !void {
    if (database.contains(name) == false) {
        try database.put(name, String.init(b.allocator));

        var text = database.getPtr(name).?;

        try text.appendSlice("---@alias ");
        try text.appendSlice(name);
        try text.appendSlice("\n");

        inline for (@typeInfo(T).Enum.fields) |field| {
            try text.appendSlice("---|\' \"");
            try text.appendSlice(field.name);
            try text.appendSlice("\" \'\n");
        }
    }
}

fn addClass(b: *std.Build, database: *Database, name: []const u8, comptime T: type) !void {
    if (database.contains(name) == false) {
        try database.put(name, String.init(b.allocator));

        const text = database.getPtr(name).?;

        try addClassName(text, name);
        try addClassFields(b, database, text, @typeInfo(T).Struct.fields);
    }
}

fn addClassName(text: *String, name: []const u8) !void {
    try text.appendSlice("---@class ");
    try text.appendSlice(name);
    try text.appendSlice("\n");
}

fn addClassField(b: *std.Build, database: *Database, text: *String, comptime field: std.builtin.Type.StructField) !void {
    try text.appendSlice("---@field ");
    try text.appendSlice(field.name);
    try text.appendSlice(" ");
    try addType(b, database, text, field.type);
    try text.appendSlice("\n");
}

fn addClassFields(
    b: *std.Build,
    database: *Database,
    text: *String,
    comptime fields: []const std.builtin.Type.StructField,
) !void {
    if (fields.len > 0) {
        try addClassField(b, database, text, fields[0]);
        try addClassFields(b, database, text, fields[1..fields.len]);
    } else {
        return;
    }
}

fn addType(b: *std.Build, database: *Database, text: *String, comptime T: type) !void {
    switch (@typeInfo(T)) {
        .Struct => {
            const name = (comptime std.fs.path.extension(@typeName(T)))[1..];
            try text.appendSlice(name);
            try addClass(b, database, name, T);
        },
        .Pointer => |info| {
            if (info.child == u8 and info.size == .Slice) {
                try text.appendSlice("string");
            } else switch (info.size) {
                .One => {
                    try text.appendSlice("lightuserdata");
                },
                .C, .Many, .Slice => {
                    try addType(b, database, text, info.child);
                    try text.appendSlice("[]");
                },
            }
        },
        .Array => |info| {
            try addType(b, database, text, info.child);
            try text.appendSlice("[]");
        },

        .Vector => |info| {
            try addType(b, database, text, info.child);
            try text.appendSlice("[]");
        },
        .Optional => |info| {
            try addType(b, database, text, info.child);
            try text.appendSlice("?");
        },
        .Enum => {
            const name = (comptime std.fs.path.extension(@typeName(T)))[1..];
            try addEnum(b, database, name, T);
            try text.appendSlice(name);
        },
        .Int => {
            try text.appendSlice("integer");
        },
        .Float => {
            try text.appendSlice("number");
        },
        .Bool => {
            try text.appendSlice("boolean");
        },
        else => @compileError("Type not supported"),
    }
}

// Warning: file contents will be lost
//fn overwriteFile(database: *Database, abs_path: []const u8) !void {
//    var file = try std.fs.openFileAbsolute(abs_path, .{ .mode = .write_only });
//    try file.seekTo(0);
//    try file.writeAll(self.getFileHeader());
//
//    var iter = self.database.valueIterator();
//    while (iter.next()) |val| {
//        try file.writeAll(val.items);
//        try file.writeAll("\n");
//    }
//    try file.setEndPos(try file.getPos());
//}
//
//pub fn printdatabase(database: *Database) !void {
//    var iter = self.database.valueIterator();
//    while (iter.next()) |val| {
//        std.debug.print("{s}\n", .{val.items});
//    }
//}
