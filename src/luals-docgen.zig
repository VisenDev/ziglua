const std = @import("std");

pub const Doc = struct {
    allocator: std.mem.Allocator,
    defined: std.StringHashMap(std.ArrayList(u8)),

    pub fn init(alloc: std.mem.Allocator) @This() {
        return .{ .defined = std.StringHashMap(std.ArrayList(u8)).init(alloc), .allocator = alloc };
    }

    pub fn deinit(self: *@This()) void {
        var iter = self.defined.valueIterator();
        while (iter.next()) |val| {
            val.deinit();
        }
        self.defined.deinit();
    }

    pub fn addFileHeader(_: *@This(), result: *std.ArrayList(u8)) !void {
        try result.appendSlice(
            \\---@meta
            \\
            \\--- This is an autogenerated file,
            \\--- Do not modify
            \\
            \\
        );
    }

    pub fn addClass(self: *@This(), name: []const u8, comptime T: type) !void {
        const is_undefined = self.defined.get(name) == null;
        if (is_undefined) {
            try self.defined.put(name, std.ArrayList(u8).init(self.allocator));
            const result = self.defined.getPtr(name).?;
            try self.addClassName(result, name);
            try self.addClassFields(result, @typeInfo(T).Struct.fields);
        }
    }

    pub fn addClassName(_: *@This(), result: *std.ArrayList(u8), name: []const u8) !void {
        try result.appendSlice("---@class ");
        try result.appendSlice(name);
        try result.appendSlice("\n");
    }

    pub fn addClassField(self: *@This(), result: *std.ArrayList(u8), comptime field: std.builtin.Type.StructField) !void {
        try result.appendSlice("---@field ");
        try result.appendSlice(field.name);
        try result.appendSlice(" ");
        try self.addType(result, field.type);
        try result.appendSlice("\n");
    }

    pub fn addClassFields(
        self: *@This(),
        result: *std.ArrayList(u8),
        comptime fields: []const std.builtin.Type.StructField,
    ) !void {
        if (fields.len > 0) {
            try self.addClassField(result, fields[0]);
            try self.addClassFields(result, fields[1..fields.len]);
        } else {
            return;
        }
    }

    pub fn addType(self: *@This(), result: *std.ArrayList(u8), comptime T: type) !void {
        switch (@typeInfo(T)) {
            .Struct => {
                const name = (comptime std.fs.path.extension(@typeName(T)))[1..];
                try self.addClass(name, T);
                try result.appendSlice(name);
            },
            .Int => {
                try result.appendSlice("Integer");
            },
            .Float => {
                try result.appendSlice("Number");
            },
            .Bool => {
                try result.appendSlice("Boolean");
            },
            else => @compileError("Type not supported"),
        }
    }

    pub fn printDefined(self: *@This()) !void {
        var iter = self.defined.valueIterator();
        while (iter.next()) |val| {
            std.debug.print("{s}\n", .{val.items});
        }
    }
};

test "docgen" {
    var docs = Doc.init(std.testing.allocator);
    defer docs.deinit();

    const SubType = struct { foo: i32, bar: bool };
    const TestType = struct { a: i32, b: f32, c: bool, d: SubType };
    try docs.addClass("TestType", TestType);
    try docs.printDefined();
}
